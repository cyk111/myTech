### 演技中的架构 #凤凰架构

### 探索起步  
#### 演进中的架构  
 - 原始分布式架构  
 - 本地服务调用 VS 远程服务调用  
 ```text
 - 保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性、完整性都要重要  
- 简单优先原则  
- 某些功能能够使用分布式，并不意味他就应该进行分布式操作，有时只会自寻其果  
- 调用远程方法”与“调用本地方法”尽管只是两字之差，但若要同时兼顾简单、透明、性能、正确、鲁棒、一致等特点的话，两者的复杂度就完全不可同日而语了  
- 远程引出的问题  
 - 服务在哪里 （服务发现） - 有多个个服务（负载均衡） - 网络出现分区 超时 服务出错怎么办（熔断 隔离 降级） - 方法的参数和返回结果如果表示（序列化协议）  - 信息如何传输（传输协议）  
 - 服务权限如何管理（认证 授权） - 如何保证通信安全（网路安全）  - 调用不同机器返回不一致（分布式一致性）  
- 服务发现、跟踪、通信、容错、隔离、配置、传输、数据一致性和编码复杂度等方面  
```  
  
- 单体系统时代  
  - 单体真正的缺点不在于如何拆分而是拆分后自治能力的欠缺   
  - 优点：  
    - 易于开发 易于部署 易于测试   
    - 进程间调用 所有模块之间不用考虑 网络分区 对象复制带来的性能损失  
  - 缺点  
    - 过渡消耗进程空间内存 所造成影响全局性、难以隔离，（内存泄露 线程爆炸 阻塞 死循环）  
    - 很难升级 更新部分代码，需要停机，做灰度测试 A/B测试相对更复杂  
      
```text  
希望系统的每一个部件，每一处代码都尽量可靠，靠不出或少出缺陷来构建可靠系统。  
然而战术层面再优秀，也很难弥补战略层面的不足，单体靠高质量来保证高可靠性的思路，  
在小规模软件上还能运作良好，但系统规模越大，交付一个可靠的单体系统就变得越来越具有挑战性  
构筑可靠系统从“追求尽量不出错”，到正视“出错是必然”的观念转变，  
才是微服务架构得以挑战并逐步开始取代运作了数十年的单体架构的底气所在。  
  
- 为了允许程序出错，为了获得隔离、自治的能力，为了可以技术异构等目标，是继为了性能与算力之后，让程序再次选择分布式的理由  
```   
- SOA时代 面向服务的架构  
 - 面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式  
 - 有清晰软件设计的指导原则，譬如服务的封装性、自治、松耦合、可重用、可组合、无状态  
 - 服务之间的松散耦合、注册、发现、治理，隔离、编排，等  
 - 历程  
    - 烟囱式架构（Information Silo Architecture），系统直接不交互，但是人员 组织 权限不可能完全独立  
    - 微内核架构 （Microkernel architecture） 插件式架构，子系统使用公共服务 数据 资源，可扩展 灵活性 天然隔离性，插件间不能直接交互  
    - 事件驱动架构（EDA Event-Driven Architecture）,事件队列管道，系统消息以事件方式发送管道，子系统获取自己感兴趣的消息消费  
      - SOAP协议族(WSDL UDDI) 来完成服务的发布 发现 治理  
      - 企业服务总线（ESB Enterprise Service Bus） 消息管道完成各个子系统的通信交互  
      - 业务流程编排（Bussiness Process Management BPM）  
      - 服务数据对象（Service Data Object SDO）访问和表示数据  
      - 服务组件架构（Service Compoment Architecture SCA）服务封装+ 服务运行容器  
```text  
SOA 诞生的那一天起，就已经注定了它只能是少数系统阳春白雪式的精致奢侈品，它可以实现多个异构大型系统之间的复杂集成交互，  
却很难作为一种具有广泛普适性的软件架构风格来推广。SOA 最终没有获得成功的致命伤与当年的EJB如出一辙，  
尽管有 Sun Microsystems 和 IBM 等一众巨头在背后力挺，EJB 仍然败于以 Spring、Hibernate 为代表的“草根框架”，  
可见一旦脱离人民群众，终究会淹没在群众的海洋之中，连信息技术也不曾例外过。  
```  
  
- 微服务的时代（Microservice）  
```text  
微服务架构（Microservices）  
微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。  
各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。  
```  
- 单一服务职责、康威定律、自动扩展、领域驱动设计等原则  
- 特点：  
  - 围绕业务能力构建   
  - 分散治理 开发团队对服务质量负责人  
  - 通过服务来实现独立自治的组件，强调服务而不是类库，进程外组件实现隔离  
  - 产品化思维 不能视为完成某种功能，而是一种持续改进提升的过程 整个生命周期负责  
  - 数据去中心化 分布式事务是这个原则的副产品，保证服务的独立性  
  - 强终端弱管道 与SOA ESB 的区别 restful 风格  
  - 容错性设计 不追求服务永远稳定，依赖快速服务故障检测，隔离，没有容错系统产生雪崩效应 ，可靠的系统完全可能有出错的服务组成，微服务最大价值所在  
  - 演进式设计  容错性设计承认服务会出错，演进式设计则是承认服务会被报废淘汰。一个设计良好的服务，应该是能够报废的，而不是期望得到长存永生  
  - 基础设施自动化 CI/CD 构建 发布 运维  
    
 - 问题 以实践为标准代替规范为标准   
 - 服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通信、事务处理  
 - 服务调用方案：  
    - RMI  
    - Thrift  
    - gRPC  
    - Motan2  
    - Finagle  
    - brpc  
    - Arvo  
    - JSON-RPC  
    - REST  
 - 服务发现方案  
    - Eureka  
    - Consul  
    - Naqcos  
    - zk  
    - etcd  
    - cncf  
 ```text作为一个普通的服务开发者，作为一个“螺丝钉”式的程序员，微服务架构是友善的。  
可是，微服务对架构者是满满的恶意，对架构能力要求已提升到史无前例的程度，  
技术架构者的第一职责就是做决策权衡，有利有弊才需要决策，有取有舍才需要权衡，  
如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中利弊，  
恐怕也就无可避免地陷入选择困难症的困境之中  
``` - 微服务时代充满着自由的气息，微服务时代充斥着迷茫的选择。软件架构不会止步于自由，微服务仍不是架构探索终点  
  
- 后微服务时代（Cloud native）  
```text  
从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”。  
```  
 - 不局限于软件解决问题         
    - 负载均衡 布置负载均衡器 选择恰当的均衡算法来分流  
    - 解决安全传输问题 布置TLS 传输链路，配置CA  
    - 解决服务发现 设置DNS 服务器  
 - 人们选择在软件的代码层面而不是硬件的基础设施层面去解决这些分布式问题，很大程度上是因为由硬件构成的基础设施，跟不上由软件构成的应用服务的灵活性的无奈之举     
  
 - 虚拟化技术 + 容器化技术 （Docker + Kubernetes）  
    - 容器编排系统的管理工具 Rancher  
      
```text  
  
Kubernetes Spring Cloud  
弹性伸缩   Autoscaling    N/A  
服务发现   KubeDNS / CoreDNS  Spring Cloud Eureka  
配置中心   ConfigMap / Secret Spring Cloud Config  
服务网关   Ingress Controller Spring Cloud Zuul  
负载均衡   Load Balancer  Spring Cloud Ribbon  
服务安全   RBAC API   Spring Cloud Security  
跟踪监控   Metrics API / Dashboard    Spring Cloud Turbine  
降级熔断   N/A    Spring Cloud Hystrix  
  
``` - 从软件层面独力应对分布式架构所带来的各种问题，发展到应用代码与基础设施软、硬一体，合力应对架构问题的时代，  
  现在常被媒体冠以“云原生”这个颇为抽象的名字加以宣传。云原生时代与此前微服务时代中追求的目标并没有本质改变，  
  在服务架构演进的历史进程中，笔者更愿意称其为“后微服务时代”  
- 有一些问题处于应用系统与基础设施的边缘，使得完全在基础设施层面中确实很难精细化地处理  
  
 - 服务网格 Service Mesh  边车模式 sidecar proxy   
 - 上帝的归上帝，凯撒的归凯撒，业务与技术完全分离，远程与本地完全透明，也许这就是最好的时代了吧？  
   
 ### 读到此处，我只能说牛逼牛逼 从没有读技术文章如此酣畅淋漓 意犹未尽   
- 无服务时代 云服务  
```text  
如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布式”的云端系统这条路的起点。  
```  
 - 后端设施 指 数据库 消息队列 日志 存储 支撑业务逻辑运行 本身无业务含义的组件 无服务中程其为"后端即服务 Backend as a Service" Baas  
 - 函数 指业务逻辑代码 云端服务 不考虑算力 不考虑容量规划  函数即服务 "Function as a service" FaaS   
  
  
  
#### 架构师的视角  
- 分布式架构  
  - SOA   
  - 微服务  
  - 服务网格  
  - 服务的注册发现 跟踪治理 负载均衡 故障隔离 认证授权 伸缩扩展 传输通信 事务处理  
#### 分布式基石  
#### 不可变基础设施  
  
  
- test  
- git config --global --edit  
### 记录  
- SSL: no alternative certificate subject name matches target host name 'xxxx.baidu.com'  
- git config --global http.sslVerify false